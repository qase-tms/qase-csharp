// <auto-generated>
/*
 * Qase.io TestOps API v1
 *
 * Qase TestOps API v1 Specification.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@qase.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Qase.ApiClient.V1.Client;
using Qase.ApiClient.V1.Model;

namespace Qase.ApiClient.V1.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IResultsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ResultsApiEvents Events { get; }

        /// <summary>
        /// Create test run result
        /// </summary>
        /// <remarks>
        /// This method allows to create test run result by Run Id. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="resultCreate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateResultApiResponse"/>&gt;</returns>
        Task<ICreateResultApiResponse> CreateResultAsync(string code, int id, ResultCreate resultCreate, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create test run result
        /// </summary>
        /// <remarks>
        /// This method allows to create test run result by Run Id. 
        /// </remarks>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="resultCreate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateResultApiResponse"/>?&gt;</returns>
        Task<ICreateResultApiResponse?> CreateResultOrDefaultAsync(string code, int id, ResultCreate resultCreate, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Bulk create test run result
        /// </summary>
        /// <remarks>
        /// This method allows to create a lot of test run result at once.  If you try to send more than 2,000 results in a single bulk request, you will receive an error with code 413 - Payload Too Large.  If there is no free space left in your team account, when attempting to upload an attachment, e.g., through reporters, you will receive an error with code 507 - Insufficient Storage. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="resultCreateBulk"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateResultBulkApiResponse"/>&gt;</returns>
        Task<ICreateResultBulkApiResponse> CreateResultBulkAsync(string code, int id, ResultCreateBulk resultCreateBulk, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Bulk create test run result
        /// </summary>
        /// <remarks>
        /// This method allows to create a lot of test run result at once.  If you try to send more than 2,000 results in a single bulk request, you will receive an error with code 413 - Payload Too Large.  If there is no free space left in your team account, when attempting to upload an attachment, e.g., through reporters, you will receive an error with code 507 - Insufficient Storage. 
        /// </remarks>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="resultCreateBulk"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateResultBulkApiResponse"/>?&gt;</returns>
        Task<ICreateResultBulkApiResponse?> CreateResultBulkOrDefaultAsync(string code, int id, ResultCreateBulk resultCreateBulk, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete test run result
        /// </summary>
        /// <remarks>
        /// This method allows to delete test run result. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteResultApiResponse"/>&gt;</returns>
        Task<IDeleteResultApiResponse> DeleteResultAsync(string code, int id, string hash, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete test run result
        /// </summary>
        /// <remarks>
        /// This method allows to delete test run result. 
        /// </remarks>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteResultApiResponse"/>?&gt;</returns>
        Task<IDeleteResultApiResponse?> DeleteResultOrDefaultAsync(string code, int id, string hash, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get test run result by code
        /// </summary>
        /// <remarks>
        /// This method allows to retrieve a specific test run result by Hash. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetResultApiResponse"/>&gt;</returns>
        Task<IGetResultApiResponse> GetResultAsync(string code, string hash, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get test run result by code
        /// </summary>
        /// <remarks>
        /// This method allows to retrieve a specific test run result by Hash. 
        /// </remarks>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetResultApiResponse"/>?&gt;</returns>
        Task<IGetResultApiResponse?> GetResultOrDefaultAsync(string code, string hash, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all test run results
        /// </summary>
        /// <remarks>
        /// This method allows to retrieve all test run results stored in selected project. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="status">A single test run result status. Possible values: in_progress, passed, failed, blocked, skipped, invalid.  (optional)</param>
        /// <param name="run">A list of run IDs separated by comma. (optional)</param>
        /// <param name="caseId">A list of case IDs separated by comma. (optional)</param>
        /// <param name="member">A list of member IDs separated by comma. (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="fromEndTime">Will return all results created after provided datetime. Allowed format: &#x60;Y-m-d H:i:s&#x60;.  (optional)</param>
        /// <param name="toEndTime">Will return all results created before provided datetime. Allowed format: &#x60;Y-m-d H:i:s&#x60;.  (optional)</param>
        /// <param name="limit">A number of entities in result set. (optional, default to 10)</param>
        /// <param name="offset">How many entities should be skipped. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetResultsApiResponse"/>&gt;</returns>
        Task<IGetResultsApiResponse> GetResultsAsync(string code, Option<string> status = default, Option<string> run = default, Option<string> caseId = default, Option<string> member = default, Option<bool> api = default, Option<string> fromEndTime = default, Option<string> toEndTime = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all test run results
        /// </summary>
        /// <remarks>
        /// This method allows to retrieve all test run results stored in selected project. 
        /// </remarks>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="status">A single test run result status. Possible values: in_progress, passed, failed, blocked, skipped, invalid.  (optional)</param>
        /// <param name="run">A list of run IDs separated by comma. (optional)</param>
        /// <param name="caseId">A list of case IDs separated by comma. (optional)</param>
        /// <param name="member">A list of member IDs separated by comma. (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="fromEndTime">Will return all results created after provided datetime. Allowed format: &#x60;Y-m-d H:i:s&#x60;.  (optional)</param>
        /// <param name="toEndTime">Will return all results created before provided datetime. Allowed format: &#x60;Y-m-d H:i:s&#x60;.  (optional)</param>
        /// <param name="limit">A number of entities in result set. (optional, default to 10)</param>
        /// <param name="offset">How many entities should be skipped. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetResultsApiResponse"/>?&gt;</returns>
        Task<IGetResultsApiResponse?> GetResultsOrDefaultAsync(string code, Option<string> status = default, Option<string> run = default, Option<string> caseId = default, Option<string> member = default, Option<bool> api = default, Option<string> fromEndTime = default, Option<string> toEndTime = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update test run result
        /// </summary>
        /// <remarks>
        /// This method allows to update test run result. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="resultUpdate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateResultApiResponse"/>&gt;</returns>
        Task<IUpdateResultApiResponse> UpdateResultAsync(string code, int id, string hash, ResultUpdate resultUpdate, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update test run result
        /// </summary>
        /// <remarks>
        /// This method allows to update test run result. 
        /// </remarks>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="resultUpdate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateResultApiResponse"/>?&gt;</returns>
        Task<IUpdateResultApiResponse?> UpdateResultOrDefaultAsync(string code, int id, string hash, ResultUpdate resultUpdate, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateResultApiResponse"/>
    /// </summary>
    public interface ICreateResultApiResponse : Qase.ApiClient.V1.Client.IApiResponse, IOk<Qase.ApiClient.V1.Model.ResultCreateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="ICreateResultBulkApiResponse"/>
    /// </summary>
    public interface ICreateResultBulkApiResponse : Qase.ApiClient.V1.Client.IApiResponse, IOk<Qase.ApiClient.V1.Model.BaseResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 413 ContentTooLarge
        /// </summary>
        /// <returns></returns>
        bool IsContentTooLarge { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteResultApiResponse"/>
    /// </summary>
    public interface IDeleteResultApiResponse : Qase.ApiClient.V1.Client.IApiResponse, IOk<Qase.ApiClient.V1.Model.HashResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IGetResultApiResponse"/>
    /// </summary>
    public interface IGetResultApiResponse : Qase.ApiClient.V1.Client.IApiResponse, IOk<Qase.ApiClient.V1.Model.ResultResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IGetResultsApiResponse"/>
    /// </summary>
    public interface IGetResultsApiResponse : Qase.ApiClient.V1.Client.IApiResponse, IOk<Qase.ApiClient.V1.Model.ResultListResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateResultApiResponse"/>
    /// </summary>
    public interface IUpdateResultApiResponse : Qase.ApiClient.V1.Client.IApiResponse, IOk<Qase.ApiClient.V1.Model.HashResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ResultsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateResult;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateResult;

        internal void ExecuteOnCreateResult(ResultsApi.CreateResultApiResponse apiResponse)
        {
            OnCreateResult?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateResult(Exception exception)
        {
            OnErrorCreateResult?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateResultBulk;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateResultBulk;

        internal void ExecuteOnCreateResultBulk(ResultsApi.CreateResultBulkApiResponse apiResponse)
        {
            OnCreateResultBulk?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateResultBulk(Exception exception)
        {
            OnErrorCreateResultBulk?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteResult;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteResult;

        internal void ExecuteOnDeleteResult(ResultsApi.DeleteResultApiResponse apiResponse)
        {
            OnDeleteResult?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteResult(Exception exception)
        {
            OnErrorDeleteResult?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetResult;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetResult;

        internal void ExecuteOnGetResult(ResultsApi.GetResultApiResponse apiResponse)
        {
            OnGetResult?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetResult(Exception exception)
        {
            OnErrorGetResult?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetResults;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetResults;

        internal void ExecuteOnGetResults(ResultsApi.GetResultsApiResponse apiResponse)
        {
            OnGetResults?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetResults(Exception exception)
        {
            OnErrorGetResults?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateResult;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateResult;

        internal void ExecuteOnUpdateResult(ResultsApi.UpdateResultApiResponse apiResponse)
        {
            OnUpdateResult?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateResult(Exception exception)
        {
            OnErrorUpdateResult?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ResultsApi : IResultsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ResultsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ResultsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ResultsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ResultsApi(ILogger<ResultsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ResultsApiEvents resultsApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ResultsApi>();
            HttpClient = httpClient;
            Events = resultsApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCreateResult(ref string code, ref int id, ResultCreate resultCreate);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="code"></param>
        /// <param name="resultCreate"></param>
        /// <returns></returns>
        private void ValidateCreateResult(string code, ResultCreate resultCreate)
        {
            if (code == null)
                throw new ArgumentNullException(nameof(code));

            if (resultCreate == null)
                throw new ArgumentNullException(nameof(resultCreate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="resultCreate"></param>
        private void AfterCreateResultDefaultImplementation(ICreateResultApiResponse apiResponseLocalVar, string code, int id, ResultCreate resultCreate)
        {
            bool suppressDefaultLog = false;
            AfterCreateResult(ref suppressDefaultLog, apiResponseLocalVar, code, id, resultCreate);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="resultCreate"></param>
        partial void AfterCreateResult(ref bool suppressDefaultLog, ICreateResultApiResponse apiResponseLocalVar, string code, int id, ResultCreate resultCreate);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="resultCreate"></param>
        private void OnErrorCreateResultDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, int id, ResultCreate resultCreate)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateResult(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, code, id, resultCreate);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="resultCreate"></param>
        partial void OnErrorCreateResult(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, int id, ResultCreate resultCreate);

        /// <summary>
        /// Create test run result This method allows to create test run result by Run Id. 
        /// </summary>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="resultCreate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateResultApiResponse"/>&gt;</returns>
        public async Task<ICreateResultApiResponse?> CreateResultOrDefaultAsync(string code, int id, ResultCreate resultCreate, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateResultAsync(code, id, resultCreate, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create test run result This method allows to create test run result by Run Id. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="resultCreate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateResultApiResponse"/>&gt;</returns>
        public async Task<ICreateResultApiResponse> CreateResultAsync(string code, int id, ResultCreate resultCreate, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateResult(code, resultCreate);

                FormatCreateResult(ref code, ref id, resultCreate);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/result/{code}/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/result/{code}/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcode%7D", Uri.EscapeDataString(code.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    httpRequestMessageLocalVar.Content = (resultCreate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(resultCreate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Token", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateResultApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateResultApiResponse>();
                        CreateResultApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                apiResponseLocalVar = new CreateResultApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/result/{code}/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateResultDefaultImplementation(apiResponseLocalVar, code, id, resultCreate);

                        Events.ExecuteOnCreateResult(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateResultDefaultImplementation(e, "/result/{code}/{id}", uriBuilderLocalVar.Path, code, id, resultCreate);
                Events.ExecuteOnErrorCreateResult(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateResultApiResponse"/>
        /// </summary>
        public partial class CreateResultApiResponse : Qase.ApiClient.V1.Client.ApiResponse, ICreateResultApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateResultApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateResultApiResponse(ILogger<CreateResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateResultApiResponse(ILogger<CreateResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Qase.ApiClient.V1.Model.ResultCreateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Qase.ApiClient.V1.Model.ResultCreateResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out Qase.ApiClient.V1.Model.ResultCreateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateResultBulk(ref string code, ref int id, ResultCreateBulk resultCreateBulk);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="code"></param>
        /// <param name="resultCreateBulk"></param>
        /// <returns></returns>
        private void ValidateCreateResultBulk(string code, ResultCreateBulk resultCreateBulk)
        {
            if (code == null)
                throw new ArgumentNullException(nameof(code));

            if (resultCreateBulk == null)
                throw new ArgumentNullException(nameof(resultCreateBulk));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="resultCreateBulk"></param>
        private void AfterCreateResultBulkDefaultImplementation(ICreateResultBulkApiResponse apiResponseLocalVar, string code, int id, ResultCreateBulk resultCreateBulk)
        {
            bool suppressDefaultLog = false;
            AfterCreateResultBulk(ref suppressDefaultLog, apiResponseLocalVar, code, id, resultCreateBulk);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="resultCreateBulk"></param>
        partial void AfterCreateResultBulk(ref bool suppressDefaultLog, ICreateResultBulkApiResponse apiResponseLocalVar, string code, int id, ResultCreateBulk resultCreateBulk);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="resultCreateBulk"></param>
        private void OnErrorCreateResultBulkDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, int id, ResultCreateBulk resultCreateBulk)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateResultBulk(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, code, id, resultCreateBulk);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="resultCreateBulk"></param>
        partial void OnErrorCreateResultBulk(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, int id, ResultCreateBulk resultCreateBulk);

        /// <summary>
        /// Bulk create test run result This method allows to create a lot of test run result at once.  If you try to send more than 2,000 results in a single bulk request, you will receive an error with code 413 - Payload Too Large.  If there is no free space left in your team account, when attempting to upload an attachment, e.g., through reporters, you will receive an error with code 507 - Insufficient Storage. 
        /// </summary>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="resultCreateBulk"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateResultBulkApiResponse"/>&gt;</returns>
        public async Task<ICreateResultBulkApiResponse?> CreateResultBulkOrDefaultAsync(string code, int id, ResultCreateBulk resultCreateBulk, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateResultBulkAsync(code, id, resultCreateBulk, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Bulk create test run result This method allows to create a lot of test run result at once.  If you try to send more than 2,000 results in a single bulk request, you will receive an error with code 413 - Payload Too Large.  If there is no free space left in your team account, when attempting to upload an attachment, e.g., through reporters, you will receive an error with code 507 - Insufficient Storage. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="resultCreateBulk"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateResultBulkApiResponse"/>&gt;</returns>
        public async Task<ICreateResultBulkApiResponse> CreateResultBulkAsync(string code, int id, ResultCreateBulk resultCreateBulk, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateResultBulk(code, resultCreateBulk);

                FormatCreateResultBulk(ref code, ref id, resultCreateBulk);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/result/{code}/{id}/bulk"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/result/{code}/{id}/bulk");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcode%7D", Uri.EscapeDataString(code.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    httpRequestMessageLocalVar.Content = (resultCreateBulk as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(resultCreateBulk, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Token", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateResultBulkApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateResultBulkApiResponse>();
                        CreateResultBulkApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                apiResponseLocalVar = new CreateResultBulkApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/result/{code}/{id}/bulk", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateResultBulkDefaultImplementation(apiResponseLocalVar, code, id, resultCreateBulk);

                        Events.ExecuteOnCreateResultBulk(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateResultBulkDefaultImplementation(e, "/result/{code}/{id}/bulk", uriBuilderLocalVar.Path, code, id, resultCreateBulk);
                Events.ExecuteOnErrorCreateResultBulk(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateResultBulkApiResponse"/>
        /// </summary>
        public partial class CreateResultBulkApiResponse : Qase.ApiClient.V1.Client.ApiResponse, ICreateResultBulkApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateResultBulkApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateResultBulkApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateResultBulkApiResponse(ILogger<CreateResultBulkApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateResultBulkApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateResultBulkApiResponse(ILogger<CreateResultBulkApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Qase.ApiClient.V1.Model.BaseResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Qase.ApiClient.V1.Model.BaseResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out Qase.ApiClient.V1.Model.BaseResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 413 ContentTooLarge
            /// </summary>
            /// <returns></returns>
            public bool IsContentTooLarge => 413 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteResult(ref string code, ref int id, ref string hash);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="code"></param>
        /// <param name="hash"></param>
        /// <returns></returns>
        private void ValidateDeleteResult(string code, string hash)
        {
            if (code == null)
                throw new ArgumentNullException(nameof(code));

            if (hash == null)
                throw new ArgumentNullException(nameof(hash));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="hash"></param>
        private void AfterDeleteResultDefaultImplementation(IDeleteResultApiResponse apiResponseLocalVar, string code, int id, string hash)
        {
            bool suppressDefaultLog = false;
            AfterDeleteResult(ref suppressDefaultLog, apiResponseLocalVar, code, id, hash);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="hash"></param>
        partial void AfterDeleteResult(ref bool suppressDefaultLog, IDeleteResultApiResponse apiResponseLocalVar, string code, int id, string hash);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="hash"></param>
        private void OnErrorDeleteResultDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, int id, string hash)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteResult(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, code, id, hash);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="hash"></param>
        partial void OnErrorDeleteResult(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, int id, string hash);

        /// <summary>
        /// Delete test run result This method allows to delete test run result. 
        /// </summary>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteResultApiResponse"/>&gt;</returns>
        public async Task<IDeleteResultApiResponse?> DeleteResultOrDefaultAsync(string code, int id, string hash, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteResultAsync(code, id, hash, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete test run result This method allows to delete test run result. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteResultApiResponse"/>&gt;</returns>
        public async Task<IDeleteResultApiResponse> DeleteResultAsync(string code, int id, string hash, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteResult(code, hash);

                FormatDeleteResult(ref code, ref id, ref hash);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/result/{code}/{id}/{hash}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/result/{code}/{id}/{hash}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcode%7D", Uri.EscapeDataString(code.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bhash%7D", Uri.EscapeDataString(hash.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Token", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteResultApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteResultApiResponse>();
                        DeleteResultApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                apiResponseLocalVar = new DeleteResultApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/result/{code}/{id}/{hash}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteResultDefaultImplementation(apiResponseLocalVar, code, id, hash);

                        Events.ExecuteOnDeleteResult(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteResultDefaultImplementation(e, "/result/{code}/{id}/{hash}", uriBuilderLocalVar.Path, code, id, hash);
                Events.ExecuteOnErrorDeleteResult(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteResultApiResponse"/>
        /// </summary>
        public partial class DeleteResultApiResponse : Qase.ApiClient.V1.Client.ApiResponse, IDeleteResultApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteResultApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteResultApiResponse(ILogger<DeleteResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteResultApiResponse(ILogger<DeleteResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Qase.ApiClient.V1.Model.HashResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Qase.ApiClient.V1.Model.HashResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out Qase.ApiClient.V1.Model.HashResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetResult(ref string code, ref string hash);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="code"></param>
        /// <param name="hash"></param>
        /// <returns></returns>
        private void ValidateGetResult(string code, string hash)
        {
            if (code == null)
                throw new ArgumentNullException(nameof(code));

            if (hash == null)
                throw new ArgumentNullException(nameof(hash));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="hash"></param>
        private void AfterGetResultDefaultImplementation(IGetResultApiResponse apiResponseLocalVar, string code, string hash)
        {
            bool suppressDefaultLog = false;
            AfterGetResult(ref suppressDefaultLog, apiResponseLocalVar, code, hash);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="hash"></param>
        partial void AfterGetResult(ref bool suppressDefaultLog, IGetResultApiResponse apiResponseLocalVar, string code, string hash);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="hash"></param>
        private void OnErrorGetResultDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, string hash)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetResult(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, code, hash);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="hash"></param>
        partial void OnErrorGetResult(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, string hash);

        /// <summary>
        /// Get test run result by code This method allows to retrieve a specific test run result by Hash. 
        /// </summary>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetResultApiResponse"/>&gt;</returns>
        public async Task<IGetResultApiResponse?> GetResultOrDefaultAsync(string code, string hash, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetResultAsync(code, hash, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get test run result by code This method allows to retrieve a specific test run result by Hash. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetResultApiResponse"/>&gt;</returns>
        public async Task<IGetResultApiResponse> GetResultAsync(string code, string hash, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetResult(code, hash);

                FormatGetResult(ref code, ref hash);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/result/{code}/{hash}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/result/{code}/{hash}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcode%7D", Uri.EscapeDataString(code.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bhash%7D", Uri.EscapeDataString(hash.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Token", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetResultApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetResultApiResponse>();
                        GetResultApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                apiResponseLocalVar = new GetResultApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/result/{code}/{hash}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetResultDefaultImplementation(apiResponseLocalVar, code, hash);

                        Events.ExecuteOnGetResult(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetResultDefaultImplementation(e, "/result/{code}/{hash}", uriBuilderLocalVar.Path, code, hash);
                Events.ExecuteOnErrorGetResult(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetResultApiResponse"/>
        /// </summary>
        public partial class GetResultApiResponse : Qase.ApiClient.V1.Client.ApiResponse, IGetResultApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetResultApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetResultApiResponse(ILogger<GetResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetResultApiResponse(ILogger<GetResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Qase.ApiClient.V1.Model.ResultResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Qase.ApiClient.V1.Model.ResultResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out Qase.ApiClient.V1.Model.ResultResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetResults(ref string code, ref Option<string> status, ref Option<string> run, ref Option<string> caseId, ref Option<string> member, ref Option<bool> api, ref Option<string> fromEndTime, ref Option<string> toEndTime, ref Option<int> limit, ref Option<int> offset);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="code"></param>
        /// <param name="status"></param>
        /// <param name="run"></param>
        /// <param name="caseId"></param>
        /// <param name="member"></param>
        /// <param name="fromEndTime"></param>
        /// <param name="toEndTime"></param>
        /// <returns></returns>
        private void ValidateGetResults(string code, Option<string> status, Option<string> run, Option<string> caseId, Option<string> member, Option<string> fromEndTime, Option<string> toEndTime)
        {
            if (code == null)
                throw new ArgumentNullException(nameof(code));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));

            if (run.IsSet && run.Value == null)
                throw new ArgumentNullException(nameof(run));

            if (caseId.IsSet && caseId.Value == null)
                throw new ArgumentNullException(nameof(caseId));

            if (member.IsSet && member.Value == null)
                throw new ArgumentNullException(nameof(member));

            if (fromEndTime.IsSet && fromEndTime.Value == null)
                throw new ArgumentNullException(nameof(fromEndTime));

            if (toEndTime.IsSet && toEndTime.Value == null)
                throw new ArgumentNullException(nameof(toEndTime));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="status"></param>
        /// <param name="run"></param>
        /// <param name="caseId"></param>
        /// <param name="member"></param>
        /// <param name="api"></param>
        /// <param name="fromEndTime"></param>
        /// <param name="toEndTime"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void AfterGetResultsDefaultImplementation(IGetResultsApiResponse apiResponseLocalVar, string code, Option<string> status, Option<string> run, Option<string> caseId, Option<string> member, Option<bool> api, Option<string> fromEndTime, Option<string> toEndTime, Option<int> limit, Option<int> offset)
        {
            bool suppressDefaultLog = false;
            AfterGetResults(ref suppressDefaultLog, apiResponseLocalVar, code, status, run, caseId, member, api, fromEndTime, toEndTime, limit, offset);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="status"></param>
        /// <param name="run"></param>
        /// <param name="caseId"></param>
        /// <param name="member"></param>
        /// <param name="api"></param>
        /// <param name="fromEndTime"></param>
        /// <param name="toEndTime"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void AfterGetResults(ref bool suppressDefaultLog, IGetResultsApiResponse apiResponseLocalVar, string code, Option<string> status, Option<string> run, Option<string> caseId, Option<string> member, Option<bool> api, Option<string> fromEndTime, Option<string> toEndTime, Option<int> limit, Option<int> offset);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="status"></param>
        /// <param name="run"></param>
        /// <param name="caseId"></param>
        /// <param name="member"></param>
        /// <param name="api"></param>
        /// <param name="fromEndTime"></param>
        /// <param name="toEndTime"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void OnErrorGetResultsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, Option<string> status, Option<string> run, Option<string> caseId, Option<string> member, Option<bool> api, Option<string> fromEndTime, Option<string> toEndTime, Option<int> limit, Option<int> offset)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetResults(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, code, status, run, caseId, member, api, fromEndTime, toEndTime, limit, offset);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="status"></param>
        /// <param name="run"></param>
        /// <param name="caseId"></param>
        /// <param name="member"></param>
        /// <param name="api"></param>
        /// <param name="fromEndTime"></param>
        /// <param name="toEndTime"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void OnErrorGetResults(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, Option<string> status, Option<string> run, Option<string> caseId, Option<string> member, Option<bool> api, Option<string> fromEndTime, Option<string> toEndTime, Option<int> limit, Option<int> offset);

        /// <summary>
        /// Get all test run results This method allows to retrieve all test run results stored in selected project. 
        /// </summary>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="status">A single test run result status. Possible values: in_progress, passed, failed, blocked, skipped, invalid.  (optional)</param>
        /// <param name="run">A list of run IDs separated by comma. (optional)</param>
        /// <param name="caseId">A list of case IDs separated by comma. (optional)</param>
        /// <param name="member">A list of member IDs separated by comma. (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="fromEndTime">Will return all results created after provided datetime. Allowed format: &#x60;Y-m-d H:i:s&#x60;.  (optional)</param>
        /// <param name="toEndTime">Will return all results created before provided datetime. Allowed format: &#x60;Y-m-d H:i:s&#x60;.  (optional)</param>
        /// <param name="limit">A number of entities in result set. (optional, default to 10)</param>
        /// <param name="offset">How many entities should be skipped. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetResultsApiResponse"/>&gt;</returns>
        public async Task<IGetResultsApiResponse?> GetResultsOrDefaultAsync(string code, Option<string> status = default, Option<string> run = default, Option<string> caseId = default, Option<string> member = default, Option<bool> api = default, Option<string> fromEndTime = default, Option<string> toEndTime = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetResultsAsync(code, status, run, caseId, member, api, fromEndTime, toEndTime, limit, offset, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all test run results This method allows to retrieve all test run results stored in selected project. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="status">A single test run result status. Possible values: in_progress, passed, failed, blocked, skipped, invalid.  (optional)</param>
        /// <param name="run">A list of run IDs separated by comma. (optional)</param>
        /// <param name="caseId">A list of case IDs separated by comma. (optional)</param>
        /// <param name="member">A list of member IDs separated by comma. (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="fromEndTime">Will return all results created after provided datetime. Allowed format: &#x60;Y-m-d H:i:s&#x60;.  (optional)</param>
        /// <param name="toEndTime">Will return all results created before provided datetime. Allowed format: &#x60;Y-m-d H:i:s&#x60;.  (optional)</param>
        /// <param name="limit">A number of entities in result set. (optional, default to 10)</param>
        /// <param name="offset">How many entities should be skipped. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetResultsApiResponse"/>&gt;</returns>
        public async Task<IGetResultsApiResponse> GetResultsAsync(string code, Option<string> status = default, Option<string> run = default, Option<string> caseId = default, Option<string> member = default, Option<bool> api = default, Option<string> fromEndTime = default, Option<string> toEndTime = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetResults(code, status, run, caseId, member, fromEndTime, toEndTime);

                FormatGetResults(ref code, ref status, ref run, ref caseId, ref member, ref api, ref fromEndTime, ref toEndTime, ref limit, ref offset);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/result/{code}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/result/{code}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcode%7D", Uri.EscapeDataString(code.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (run.IsSet)
                        parseQueryStringLocalVar["run"] = ClientUtils.ParameterToString(run.Value);

                    if (caseId.IsSet)
                        parseQueryStringLocalVar["case_id"] = ClientUtils.ParameterToString(caseId.Value);

                    if (member.IsSet)
                        parseQueryStringLocalVar["member"] = ClientUtils.ParameterToString(member.Value);

                    if (api.IsSet)
                        parseQueryStringLocalVar["api"] = ClientUtils.ParameterToString(api.Value);

                    if (fromEndTime.IsSet)
                        parseQueryStringLocalVar["from_end_time"] = ClientUtils.ParameterToString(fromEndTime.Value);

                    if (toEndTime.IsSet)
                        parseQueryStringLocalVar["to_end_time"] = ClientUtils.ParameterToString(toEndTime.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Token", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetResultsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetResultsApiResponse>();
                        GetResultsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                apiResponseLocalVar = new GetResultsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/result/{code}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetResultsDefaultImplementation(apiResponseLocalVar, code, status, run, caseId, member, api, fromEndTime, toEndTime, limit, offset);

                        Events.ExecuteOnGetResults(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetResultsDefaultImplementation(e, "/result/{code}", uriBuilderLocalVar.Path, code, status, run, caseId, member, api, fromEndTime, toEndTime, limit, offset);
                Events.ExecuteOnErrorGetResults(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetResultsApiResponse"/>
        /// </summary>
        public partial class GetResultsApiResponse : Qase.ApiClient.V1.Client.ApiResponse, IGetResultsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetResultsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetResultsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetResultsApiResponse(ILogger<GetResultsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetResultsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetResultsApiResponse(ILogger<GetResultsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Qase.ApiClient.V1.Model.ResultListResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Qase.ApiClient.V1.Model.ResultListResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out Qase.ApiClient.V1.Model.ResultListResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateResult(ref string code, ref int id, ref string hash, ResultUpdate resultUpdate);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="code"></param>
        /// <param name="hash"></param>
        /// <param name="resultUpdate"></param>
        /// <returns></returns>
        private void ValidateUpdateResult(string code, string hash, ResultUpdate resultUpdate)
        {
            if (code == null)
                throw new ArgumentNullException(nameof(code));

            if (hash == null)
                throw new ArgumentNullException(nameof(hash));

            if (resultUpdate == null)
                throw new ArgumentNullException(nameof(resultUpdate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="hash"></param>
        /// <param name="resultUpdate"></param>
        private void AfterUpdateResultDefaultImplementation(IUpdateResultApiResponse apiResponseLocalVar, string code, int id, string hash, ResultUpdate resultUpdate)
        {
            bool suppressDefaultLog = false;
            AfterUpdateResult(ref suppressDefaultLog, apiResponseLocalVar, code, id, hash, resultUpdate);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="hash"></param>
        /// <param name="resultUpdate"></param>
        partial void AfterUpdateResult(ref bool suppressDefaultLog, IUpdateResultApiResponse apiResponseLocalVar, string code, int id, string hash, ResultUpdate resultUpdate);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="hash"></param>
        /// <param name="resultUpdate"></param>
        private void OnErrorUpdateResultDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, int id, string hash, ResultUpdate resultUpdate)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateResult(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, code, id, hash, resultUpdate);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="code"></param>
        /// <param name="id"></param>
        /// <param name="hash"></param>
        /// <param name="resultUpdate"></param>
        partial void OnErrorUpdateResult(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string code, int id, string hash, ResultUpdate resultUpdate);

        /// <summary>
        /// Update test run result This method allows to update test run result. 
        /// </summary>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="resultUpdate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateResultApiResponse"/>&gt;</returns>
        public async Task<IUpdateResultApiResponse?> UpdateResultOrDefaultAsync(string code, int id, string hash, ResultUpdate resultUpdate, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateResultAsync(code, id, hash, resultUpdate, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update test run result This method allows to update test run result. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">Code of project, where to search entities.</param>
        /// <param name="id">Identifier.</param>
        /// <param name="hash">Hash.</param>
        /// <param name="resultUpdate"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateResultApiResponse"/>&gt;</returns>
        public async Task<IUpdateResultApiResponse> UpdateResultAsync(string code, int id, string hash, ResultUpdate resultUpdate, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateResult(code, hash, resultUpdate);

                FormatUpdateResult(ref code, ref id, ref hash, resultUpdate);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/result/{code}/{id}/{hash}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/result/{code}/{id}/{hash}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcode%7D", Uri.EscapeDataString(code.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bhash%7D", Uri.EscapeDataString(hash.ToString()));

                    httpRequestMessageLocalVar.Content = (resultUpdate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(resultUpdate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Token", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("PATCH");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateResultApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateResultApiResponse>();
                        UpdateResultApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);
                                apiResponseLocalVar = new UpdateResultApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/result/{code}/{id}/{hash}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateResultDefaultImplementation(apiResponseLocalVar, code, id, hash, resultUpdate);

                        Events.ExecuteOnUpdateResult(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateResultDefaultImplementation(e, "/result/{code}/{id}/{hash}", uriBuilderLocalVar.Path, code, id, hash, resultUpdate);
                Events.ExecuteOnErrorUpdateResult(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateResultApiResponse"/>
        /// </summary>
        public partial class UpdateResultApiResponse : Qase.ApiClient.V1.Client.ApiResponse, IUpdateResultApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateResultApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateResultApiResponse(ILogger<UpdateResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateResultApiResponse(ILogger<UpdateResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Qase.ApiClient.V1.Model.HashResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Qase.ApiClient.V1.Model.HashResponse>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out Qase.ApiClient.V1.Model.HashResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
